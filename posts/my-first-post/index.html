<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
    <meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="still finding myself🐣">
<title>
    My First Post - Color
</title>


<link rel="shortcut icon" href="/sam.ico">







<link rel="stylesheet" href="/css/main.css" media="screen">




  






<link rel="stylesheet" href="/fonts/didact_gothic/Didact_Gothic.css">




<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="My First Post"/>
<meta name="twitter:description" content="2 月 1 号发布的 Go 1.20 中有一些改动，其中，预定义的 comparable 类型约束会适用于所有的可比较类型（comparable type）。令人惊讶的是，在 Go 1.20 之前，一些可比较的类型并不满足可比较性！
如果你对可比较类型抱有疑问，那来对地方了。
思考下列有效 map 定义：
var lookupTable map[any]string 该 map 的 key 为 any（是可比较类型）。在 Go 中这会正常通过，另一方面，在 Go 1.20 前，可以用泛型改成类似这样：
type genericLookupTable[K comparable, V any] map[K]V 看起来能像常规的 map 来使用。但当使用 any 来作为 map 的 key 时会报出编译错误。
var lookupTable genericLookupTable[any, string] // ERROR: any does not implement comparable (Go 1.18 and Go 1.19) 从 Go 1.20 开始，这个代码会编译正常。
在 Go 1.20 前 comparable 类型的表现会十分恼人，因为当我们最初希望写泛型库时，它会阻止我们使用泛型。 计划写 maps."/>

<meta property="og:title" content="My First Post" />
<meta property="og:description" content="2 月 1 号发布的 Go 1.20 中有一些改动，其中，预定义的 comparable 类型约束会适用于所有的可比较类型（comparable type）。令人惊讶的是，在 Go 1.20 之前，一些可比较的类型并不满足可比较性！
如果你对可比较类型抱有疑问，那来对地方了。
思考下列有效 map 定义：
var lookupTable map[any]string 该 map 的 key 为 any（是可比较类型）。在 Go 中这会正常通过，另一方面，在 Go 1.20 前，可以用泛型改成类似这样：
type genericLookupTable[K comparable, V any] map[K]V 看起来能像常规的 map 来使用。但当使用 any 来作为 map 的 key 时会报出编译错误。
var lookupTable genericLookupTable[any, string] // ERROR: any does not implement comparable (Go 1.18 and Go 1.19) 从 Go 1.20 开始，这个代码会编译正常。
在 Go 1.20 前 comparable 类型的表现会十分恼人，因为当我们最初希望写泛型库时，它会阻止我们使用泛型。 计划写 maps." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/my-first-post/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T01:09:07+08:00" />
<meta property="article:modified_time" content="2022-11-27T01:09:07+08:00" /><meta property="og:site_name" content="todo" />



    

    
    
    
</head>

<body>
    
    
    <header class="wrap flex-container">
        <h1>My First Post</h1>
    </header>
    
    <main class="wrap">
        
<div class="flex-container">
    <aside role="complementary">
        Sun Nov 27, 2022 &#183; 254 words
        <div class="tag-container">
            
            
            <span class="tag">
                <a href="/tags/blog/">
                    blog
                </a>
            </span>
            
            
            
            <span class="tag">
                <a href="/tags/story/">
                    story
                </a>
            </span>
            
            
        </div>
    </aside>
    <hr />
    <article role="article">
        <p>2 月 1 号发布的 Go 1.20 中有一些改动，其中，预定义的 <code>comparable</code> 类型约束会适用于所有的可比较类型（comparable type）。令人惊讶的是，在 Go 1.20 之前，一些可比较的类型并不满足可比较性！</p>
<p>如果你对可比较类型抱有疑问，那来对地方了。</p>
<p>思考下列有效 map 定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lookupTable</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">any</span>]<span style="color:#66d9ef">string</span>
</span></span></code></pre></div><p>该 map 的 key 为 any（是可比较类型）。在 Go 中这会正常通过，另一方面，在 Go 1.20 前，可以用泛型改成类似这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">genericLookupTable</span>[<span style="color:#a6e22e">K</span> <span style="color:#a6e22e">comparable</span>, <span style="color:#a6e22e">V</span> <span style="color:#a6e22e">any</span>] <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">K</span>]<span style="color:#a6e22e">V</span>
</span></span></code></pre></div><p>看起来能像常规的 map 来使用。但当使用 any 来作为 map 的 key 时会报出编译错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lookupTable</span> <span style="color:#a6e22e">genericLookupTable</span>[<span style="color:#a6e22e">any</span>, <span style="color:#66d9ef">string</span>] <span style="color:#75715e">// ERROR: any does not implement comparable (Go 1.18 and Go 1.19)
</span></span></span></code></pre></div><p>从 Go 1.20 开始，这个代码会编译正常。</p>
<p>在 Go 1.20 前 <code>comparable</code> 类型的表现会十分恼人，因为当我们最初希望写泛型库时，它会阻止我们使用泛型。
计划写 <code>maps.Clone</code> 的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Clone</span>[<span style="color:#a6e22e">M</span> <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">K</span>]<span style="color:#a6e22e">V</span>, <span style="color:#a6e22e">K</span> <span style="color:#a6e22e">comparable</span>, <span style="color:#a6e22e">V</span> <span style="color:#a6e22e">any</span>](<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">M</span>) <span style="color:#a6e22e">M</span> { <span style="color:#960050;background-color:#1e0010">…</span> }
</span></span></code></pre></div><p>它可以被写出来，但由于与 <code>genericLookupTable</code> 相同的原因，它不能用于像 <code>lookupTable</code> 这样的映射表，因为我们的 <code>genericLookupTable</code> 无法使用 any 类型作为 key 的类型。</p>
<p>在本文中，我们希望揭示这背后的语言机制。为了做到这一点，从一些背景知识开始了解。</p>

<h2 id="type-parameters-andconstraints" class="anchor-link"><a href="#type-parameters-andconstraints">Type parameters and constraints<span class="pilcrow">&nbsp;¶</span></a></h2>
<p>Go 1.18 介绍并引入了泛型，相应的，type parameters 被引入作为新的语言构造。</p>
<p>在通常的函数中，一个变量可以遍历到的值集合受参数类型的限制。类似的，在泛型函数或者类型中，类型变量 type parameters 可以遍历到的类型的集合受 type constraints 的限制。因此，type constraints 定义了具体的类型集合可以被作为类型参数。</p>
<p>Go 1.18 也改变了看待 interface 的视角：在此之前，一个 interface 定义了一系列方法集合。现在，interface 定义一系列类型集合。这个新的视角是完全的向后兼容的：对于 interface 定义的方法集合时，我们可以假设所有类型的集合（无限集）都实现了这些方法。举例：<code>io.Writer</code> 接口可以认为所有类型的集合（无限集）都有适当签名的 <code>Write</code> 方法。因为具有必须的 <code>Write</code> 方法，所有的这些类型都实现了接口。</p>
<p>但新的类型集合视角会比这更加强大：我们可以用来明确的表述类型的集合，不只是间接的从方法来表述。这给了我们一种控制类型的新方式。从 Go 1.18 开始，interface 不仅仅作为通常的 interface 嵌入使用，也可以是 any 类型，类型集合或是共享同一 underlying type 的类型无限集。这些类型随后包括在类型集计算中：联合符号 A|B 表示“类型 A 或类型 B”，~T 表示“所有具有基础类型 T 的类型”。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">int</span> | <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>interface 定义了包括 int 和 string 的所有类型集合并实现了 io. Writer 接口。
这类泛型 interface 不能作为参数类型，但因为其定义了 type constraints 约束的类型集合，可以在泛型函数中这样用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">min</span>[<span style="color:#a6e22e">P</span> <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">int64</span> | <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">float64</span>](<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#a6e22e">P</span>) <span style="color:#a6e22e">P</span> { <span style="color:#960050;background-color:#1e0010">…</span> }
</span></span></code></pre></div><p>该函数能接收任意 int64 和 float64 的参数，更现实的实现方式是使用 type constraints 的 <code>&lt;</code> 操作符来枚举所有基础类型。
另一方面，由于没有方法的详细枚举类型是更通俗的，小小的语法糖可以使我们忽略闭包 interface 的使用，使用更紧凑惯用的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">min</span>[<span style="color:#a6e22e">P</span> <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">int64</span> | <span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">float64</span>](<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#a6e22e">P</span>) <span style="color:#a6e22e">P</span> { <span style="color:#960050;background-color:#1e0010">…</span> }
</span></span></code></pre></div><p>有了这种对于类型的新视角，也需要一种用于阐述接口实现的方式。如果非 interface 类型 T 是 interface 集合中的一种，则该类型 T 实现了此 interface I 。如果 T 为 interface 本身，T 定义了类型集合。所有在该类型集合中的单一集合同时也在 interface I 的类型集合中，否则 T 并未实现 I。因此，T 为 interface 的情况下，T 的类型集合需要是 I 的类型集合的子集。</p>
<p>现在我们已经有了所有要素来理解 constraint 条件满足。正如我们之前所看到的，类型约束描述了类型参数的可接受参数类型集。如果类型参数满足相应的类型约束，则该类型参数在约束接口描述的集合中。这是另一种说法，即类型参数实现了约束。在 Go 1.18 和 Go 1.19 中，约束满足意味着约束实现。很快就会看到的，Go 1.20 中的约束满足不再完全等同于约束实现。</p>

<h2 id="reference" class="anchor-link"><a href="#reference">Reference<span class="pilcrow">&nbsp;¶</span></a></h2>
<ol>
<li><a href="https://go.dev/blog/comparable">All your comparable types</a></li>
</ol>

    </article>
</div>


        
<nav role="navigation" class="flex-container bottom-menu">
    
<hr />
<p>


    
        <a href="/posts">back</a>
        
            &#183;
        
    

    
        
            
            <a href="/gallery">wanna be a photographer</a>
        
            
                &#183;
            
            <a href="/posts">wanna be a blogger</a>
        
            
                &#183;
            
            <a href="/about">about me</a>
        
        
        
            &#183; 
            <a href="/">
                main
            </a>
        
    
</p>
</nav>

    </main>
    
    <footer class="flex-container footer">
</footer>
    
    
</body>

</html>