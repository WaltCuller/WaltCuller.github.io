<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
    <meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<meta name="description" content="still finding myself🐣">
<title>
    My Third Post - Color
</title>


<link rel="shortcut icon" href="/sam.ico">







<link rel="stylesheet" href="/css/main.css" media="screen">




  






<link rel="stylesheet" href="/fonts/didact_gothic/Didact_Gothic.css">




<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="My Third Post"/>
<meta name="twitter:description" content="Kubernetes Probes (and Why They Matter for Autoscaling)&nbsp;¶ K8s 探针以及与自动扩缩容的关系&nbsp;¶ 为了确认线上应用的健康状态，可以使用探针来监控和采集其他影响容器的信息。
确认运行在 K8s 上的工作应用的状态健康对于应用的运行起到决定性作用。为了管理不同工作负载的健康状态，通过采集操作系统和应用组件并集中在监控工具上来实现信息的遥测和后续诊断。一旦有变动，这份监测数据可以分享给多个角色，包括系统管理者、DevOps 团队、SRE团队等，帮助他们决策和应对。
采集遥测信息的一种方案是使用探针机制。探针进程可以进行诊断检查，因此健康探针可以确认应用是可用并持续工作状态，从 load balancer 传递到指定终端，如 web应用集合。如果探针正常工作情况下，终端没有对应响应，load balancer 会忽略该错误终端而不是传递给用户错误内容。
可以使用 K8s 探针机制来完成在 K8s 内的多种检查。Probe 进程作为运行在每个 K8s 节点的主节点 agent，由 kubelet 周期性的作用于工作容器。K8s 探针允许用户确认集群内的 Pods 状态。为了确保工作应用的监控与功能可用，可以使用 K8s 探针来监测和采集一些影响容器的事件，如自动扩缩。
本文章会详解不同种类的探针和其主要侧重，讨论探针如何工作并且如何作用于 autoscaling。然后会着重于探针的正确配置，并解释有效实验是调整探针配置的关键。
有效利用 K8s 探针&nbsp;¶ 不同种类的 K8s 探针&nbsp;¶ 在开始探索如何有效使用 K8s 探针之前，需要使用者熟悉三种 K8s 探针类型：
startup readiness liveness startup&nbsp;¶ Startup 探针是最先运行的探针，可以通知 kubelet 应用容器是否成功启动，其余两种探针会被暂时停用，直到 startup 探针指示为成功状态。
例： 当需要监测容器的慢启动时，假如使用 liveness 探针，应用可能因为对启动的错误判断而被过早 terminated，而使用 startup 探针可以准确有效判断容器启动。
readiness&nbsp;¶ Readiness 探针提供了 Kubernetes 集群中容器是否可以接受请求，承接流量的信息。 当 readiness 探针处于失败状态，不会有网络请求送至 pod。所以，该 pod 会从相关 service 中移除。"/>

<meta property="og:title" content="My Third Post" />
<meta property="og:description" content="Kubernetes Probes (and Why They Matter for Autoscaling)&nbsp;¶ K8s 探针以及与自动扩缩容的关系&nbsp;¶ 为了确认线上应用的健康状态，可以使用探针来监控和采集其他影响容器的信息。
确认运行在 K8s 上的工作应用的状态健康对于应用的运行起到决定性作用。为了管理不同工作负载的健康状态，通过采集操作系统和应用组件并集中在监控工具上来实现信息的遥测和后续诊断。一旦有变动，这份监测数据可以分享给多个角色，包括系统管理者、DevOps 团队、SRE团队等，帮助他们决策和应对。
采集遥测信息的一种方案是使用探针机制。探针进程可以进行诊断检查，因此健康探针可以确认应用是可用并持续工作状态，从 load balancer 传递到指定终端，如 web应用集合。如果探针正常工作情况下，终端没有对应响应，load balancer 会忽略该错误终端而不是传递给用户错误内容。
可以使用 K8s 探针机制来完成在 K8s 内的多种检查。Probe 进程作为运行在每个 K8s 节点的主节点 agent，由 kubelet 周期性的作用于工作容器。K8s 探针允许用户确认集群内的 Pods 状态。为了确保工作应用的监控与功能可用，可以使用 K8s 探针来监测和采集一些影响容器的事件，如自动扩缩。
本文章会详解不同种类的探针和其主要侧重，讨论探针如何工作并且如何作用于 autoscaling。然后会着重于探针的正确配置，并解释有效实验是调整探针配置的关键。
有效利用 K8s 探针&nbsp;¶ 不同种类的 K8s 探针&nbsp;¶ 在开始探索如何有效使用 K8s 探针之前，需要使用者熟悉三种 K8s 探针类型：
startup readiness liveness startup&nbsp;¶ Startup 探针是最先运行的探针，可以通知 kubelet 应用容器是否成功启动，其余两种探针会被暂时停用，直到 startup 探针指示为成功状态。
例： 当需要监测容器的慢启动时，假如使用 liveness 探针，应用可能因为对启动的错误判断而被过早 terminated，而使用 startup 探针可以准确有效判断容器启动。
readiness&nbsp;¶ Readiness 探针提供了 Kubernetes 集群中容器是否可以接受请求，承接流量的信息。 当 readiness 探针处于失败状态，不会有网络请求送至 pod。所以，该 pod 会从相关 service 中移除。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/kubernetes-probes-and-why-they-matter-for-autoscaling/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-14T01:55:39+08:00" />
<meta property="article:modified_time" content="2023-02-14T01:55:39+08:00" /><meta property="og:site_name" content="todo" />



    

    
    
    
</head>

<body>
    
    
    <header class="wrap flex-container">
        <h1>My Third Post</h1>
    </header>
    
    <main class="wrap">
        
<div class="flex-container">
    <aside role="complementary">
        Tue Feb 14, 2023 &#183; 290 words
        <div class="tag-container">
            
            
            <span class="tag">
                <a href="/tags/blog/">
                    blog
                </a>
            </span>
            
            
            
            <span class="tag">
                <a href="/tags/story/">
                    story
                </a>
            </span>
            
            
            
            <span class="tag">
                <a href="/tags/translate/">
                    translate
                </a>
            </span>
            
            
        </div>
    </aside>
    <hr />
    <article role="article">
        
<h1 id="kubernetes-probes-and-why-they-matter-for-autoscaling" class="anchor-link"><a href="#kubernetes-probes-and-why-they-matter-for-autoscaling">Kubernetes Probes (and Why They Matter for Autoscaling)<span class="pilcrow">&nbsp;¶</span></a></h1>

<h1 id="k8s-探针以及与自动扩缩容的关系" class="anchor-link"><a href="#k8s-%e6%8e%a2%e9%92%88%e4%bb%a5%e5%8f%8a%e4%b8%8e%e8%87%aa%e5%8a%a8%e6%89%a9%e7%bc%a9%e5%ae%b9%e7%9a%84%e5%85%b3%e7%b3%bb">K8s 探针以及与自动扩缩容的关系<span class="pilcrow">&nbsp;¶</span></a></h1>
<blockquote>
<p>为了确认线上应用的健康状态，可以使用探针来监控和采集其他影响容器的信息。</p>
</blockquote>
<p>确认运行在 K8s 上的工作应用的状态健康对于应用的运行起到决定性作用。为了管理不同工作负载的健康状态，通过采集操作系统和应用组件并集中在监控工具上来实现信息的遥测和后续诊断。一旦有变动，这份监测数据可以分享给多个角色，包括系统管理者、DevOps 团队、SRE团队等，帮助他们决策和应对。</p>
<p>采集遥测信息的一种方案是使用探针机制。探针进程可以进行诊断检查，因此健康探针可以确认应用是可用并持续工作状态，从 load balancer 传递到指定终端，如 web应用集合。如果探针正常工作情况下，终端没有对应响应，load balancer 会忽略该错误终端而不是传递给用户错误内容。</p>
<p>可以使用 K8s 探针机制来完成在 K8s 内的多种检查。Probe 进程作为运行在每个 K8s 节点的主节点 agent，由 kubelet 周期性的作用于工作容器。K8s 探针允许用户确认集群内的 Pods 状态。为了确保工作应用的监控与功能可用，可以使用 K8s 探针来监测和采集一些影响容器的事件，如自动扩缩。</p>
<p>本文章会详解不同种类的探针和其主要侧重，讨论探针如何工作并且如何作用于 autoscaling。然后会着重于探针的正确配置，并解释有效实验是调整探针配置的关键。</p>

<h2 id="有效利用-k8s-探针" class="anchor-link"><a href="#%e6%9c%89%e6%95%88%e5%88%a9%e7%94%a8-k8s-%e6%8e%a2%e9%92%88">有效利用 K8s 探针<span class="pilcrow">&nbsp;¶</span></a></h2>

<h3 id="不同种类的-k8s-探针" class="anchor-link"><a href="#%e4%b8%8d%e5%90%8c%e7%a7%8d%e7%b1%bb%e7%9a%84-k8s-%e6%8e%a2%e9%92%88">不同种类的 K8s 探针<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>在开始探索如何有效使用 K8s 探针之前，需要使用者熟悉三种 K8s 探针类型：</p>
<ul>
<li>startup</li>
<li>readiness</li>
<li>liveness</li>
</ul>

<h4 id="startup" class="anchor-link"><a href="#startup">startup<span class="pilcrow">&nbsp;¶</span></a></h4>
<p>Startup 探针是最先运行的探针，可以通知 kubelet 应用容器是否成功启动，其余两种探针会被暂时停用，直到 startup 探针指示为成功状态。</p>
<p>例：
当需要监测容器的慢启动时，假如使用 liveness 探针，应用可能因为对启动的错误判断而被过早 terminated，而使用 startup 探针可以准确有效判断容器启动。</p>

<h4 id="readiness" class="anchor-link"><a href="#readiness">readiness<span class="pilcrow">&nbsp;¶</span></a></h4>
<p>Readiness 探针提供了 Kubernetes 集群中容器是否可以接受请求，承接流量的信息。
当 readiness 探针处于失败状态，不会有网络请求送至 pod。所以，该 pod 会从相关 service 中移除。</p>
<p>Readiness 探针可以确保运行在容器中的应用 100% 能被使用。然而，在某些情况下，readiness 探针无法做到 100%。一个例子是：死锁情况，当应用进程确实一直保持运行，但无法处理任何请求。Readiness 探针无法探测这种情况，这种情况会被判定为正常运行。此时需要 liveness 和 readiness 来共同判断。</p>
<blockquote>
<p>Liveness 和 Readiness 是否总是需要一起用？
这取决于容器应用本身的性质。
Readiness 探针主要用来确认容器是否能承接网络请求，当该容器无需对外承接流量时，可以忽略 readiness 探针。</p>
</blockquote>

<h4 id="liveness" class="anchor-link"><a href="#liveness">liveness<span class="pilcrow">&nbsp;¶</span></a></h4>
<p>Liveness 探针确保了容器是否正常运行。当从 liveness 探针的信号显示为非运行状态，kubelet 处理该信号并结束非运行容器进程。直接的会导致该容器重新启动，除非容器配置发生变动。</p>
<p>但即使 liveness 探针能确认容器运行状态，但不能确保容器内业务运行正常。Pod 可能处于就绪状态，但不意味着应用可以处理网络请求。</p>
<p>例：
一个 web 应用因不能连接用于查询信息的后端数据库报出 HTTP 503 请求错误。从 liveness 探针的视角看，该容器响应了请求内容，是正常运行状态。其实应用因为不能连接数据库，处于一个非正常工作状态。</p>

<h3 id="k8s-探针与自动扩缩容" class="anchor-link"><a href="#k8s-%e6%8e%a2%e9%92%88%e4%b8%8e%e8%87%aa%e5%8a%a8%e6%89%a9%e7%bc%a9%e5%ae%b9">K8s 探针与自动扩缩容<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>如上文所述，Kubernetes 探针在帮助用户了解其应用健康状态上帮助许多。探针机制也能够通过各种健康状态指标来帮助更好更有效的自动扩缩。</p>
<p>Pod 的水平自动扩缩会在 Pod 被自动添加到支持应用扩展的工作区，并且有 CPU、内存等其他关键资源的需求时触发。水平自动扩缩自动停止并移除不必要的 pod，每当关键资源需求降低。在对扩展或缩容计算需求的类似响应种，使用更大或更小的资源量重新配置 Pod 时，会应用 Pod 的垂直自动扩缩。</p>
<p>Kubernetes 自动扩缩容并不强制依赖探针机制。但探针的使用能揭示自动扩缩过程并验证容器实际的状态是启动或者关闭等。整个流程会成功得使扩缩容事件更加快速且有效。</p>
<blockquote>
<p>三种探针的正确选择和使用对于完善的自动扩缩容起到决定性的促进作用。</p>
</blockquote>
<p>当设置的探针在合理的周期内未返回成功结果，多余的 pod 会被自动增删来达到扩缩容的需求，实际上一旦探针成功返回并将第一组 pod 标记为就绪，这些 pod 是否多余已经确定。</p>

<h3 id="探针配置参数" class="anchor-link"><a href="#%e6%8e%a2%e9%92%88%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0">探针配置参数<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>Kubernetes 为探针提供了多种参数，可以通过修改这些参数来调整探针配置。</p>
<p>每种参数都有缺省的值，但在具体场景下需要配置不同的值。例如：探针配置了缺省的参数值，但无法提供具体情况下充足的信息来解释应用慢启动，或是缺省值配置的探针获取了过多无用信息，这使得获取有效结论变得困难。</p>

<h4 id="配置参数" class="anchor-link"><a href="#%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0">配置参数<span class="pilcrow">&nbsp;¶</span></a></h4>
<ul>
<li>timeoutSeconds</li>
<li>periodSeconds</li>
<li>failureThreshold</li>
<li>initialDelaySeconds</li>
<li>successThreshold</li>
</ul>

<h3 id="合理配置探针的意义" class="anchor-link"><a href="#%e5%90%88%e7%90%86%e9%85%8d%e7%bd%ae%e6%8e%a2%e9%92%88%e7%9a%84%e6%84%8f%e4%b9%89">合理配置探针的意义<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>鉴于管理和运行 Kubernetes 容器的复杂程度，确定探针参数的合理配置是具有挑战性的。需要用户了解其应用的启动快慢与否，并且在负载下如何表现以达到 SLA 或者 SLO 标准，来决定各种探针配置。
不同参数和配置间的组合以及其内部之间的交互是需要考量的，这意味着探针调整不是具体明确的科学。</p>
<p>通常在测试环境中执行，探测实验能够验证不同的参数设置并了解它们如何影响 Kubernetes pod 的行为。它还有助于了解容器、应用程序和集群的整体健康状况。</p>
<p>通过使用探针实验过程在不同场景中运行多个测试，可以提高探针参数设置的准确性。</p>

<h3 id="配置-k8s-探针" class="anchor-link"><a href="#%e9%85%8d%e7%bd%ae-k8s-%e6%8e%a2%e9%92%88">配置 K8s 探针<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>探针及其相应参数均通过 Kubernetes YAML 文件进行配置，类似于其他 Kubernetes 资源的部署方式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span><span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">test</span>: <span style="color:#ae81ff">readiness</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">name</span>: <span style="color:#ae81ff">readiness-demo</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">probe-app</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry.k8s.io/alpine</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span><span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">readinessProbe</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">httpGet:</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">path</span>: <span style="color:#f92672">/health</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">timeoutSeconds</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">livenessProbe</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">httpGet:exec</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/health</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">15</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">timeoutSeconds</span>: <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>该例子中，容器监听在 8080 端口并且有/health 的 API 用来做应用健康检查。这有助于验证容器的 readiness 和 liveness 状态。</p>
<p>Readiness 探针 GET 请求访问，设置 5 秒延迟和 1 秒超时返回。当在指定时间内返回成功的 HTTP 200 时，该容器会被认为 readiness 就绪。</p>
<p>Liveness 探针也是类似，但它被用来确认容器是否运行并可以返回请求响应。在该例子中，其具有 15 秒的延迟和 1 秒的超时返回。当 liveness 探针失败，Kubernetes 会尝试重启并恢复该容器。</p>
<p>Liveness 和 Readiness 都有助于确保我们的应用程序正常运行，并且可以处理来自 Kubernetes 集群其他部分的请求。</p>

<h3 id="使用基于机器学习的探针的意义" class="anchor-link"><a href="#%e4%bd%bf%e7%94%a8%e5%9f%ba%e4%ba%8e%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%9a%84%e6%8e%a2%e9%92%88%e7%9a%84%e6%84%8f%e4%b9%89">使用基于机器学习的探针的意义<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>为这些探头设置选择正确的参数或它们的值时没有黄金法则。可以使用手动方法开始调整和测试不同的探测器值，验证对容器行为的影响以及基于探测器运行容器的自动缩放方面。</p>
<p>然而，这种手动方法将是一个乏味、耗时且可能昂贵的过程。此外，很可能无法收集足够的数据点来在合理的时间内提供准确的配置决策。</p>
<p>做出这些准确的配置决策的关键是利用自动化和基于 ML 的实验工具，能够收集足够的支持数据点，说明各种配置组合如何影响和实现所需的探测行为。</p>

<h3 id="结论" class="anchor-link"><a href="#%e7%bb%93%e8%ae%ba">结论<span class="pilcrow">&nbsp;¶</span></a></h3>
<p>在本文中，探讨了健康检查对于验证容器的重要作用，以及 Kubernetes 探针机制如何能够执行这些检查。它们包括 startup 探针，用于验证容器工作负载的启动顺序，以及定期执行诊断测试以帮助我们了解正在运行的容器和应用程序的健康状况的 readiness 探针和 liveness 探针。</p>
<p>为了有效地使用 Kubernetes 探针，需要尝试不同的探针参数，并进行多项考虑实际应用程序或容器环境条件的测试，包括峰值负载、慢启动和缩小规模。调整探针参数的准确性越高，探针检查、自动缩放功能和整体 Kubernetes 应用程序性能就会越好。然而，手动实验是乏味且耗时的。在当今复杂的应用环境中，利用自动化和基于 ML 的实验工具将帮助用户更快、更准确地找到正确的探针设置。</p>

<h1 id="from" class="anchor-link"><a href="#from">From<span class="pilcrow">&nbsp;¶</span></a></h1>
<ol>
<li>[Kubernetes Probes (and Why They Matter for Autoscaling)](https://thenewstack. io/kubernetes-probes-and-why-they-matter-for-autoscaling/? utm_content=buffer74fd8&amp;utm_medium=social&amp;utm_source=twitter. com&amp;utm_campaign=buffer)</li>
</ol>

    </article>
</div>


        
<nav role="navigation" class="flex-container bottom-menu">
    
<hr />
<p>


    
        <a href="/posts">back</a>
        
            &#183;
        
    

    
        
            
            <a href="/gallery">wanna be a photographer</a>
        
            
                &#183;
            
            <a href="/posts">wanna be a blogger</a>
        
            
                &#183;
            
            <a href="/about">about me</a>
        
        
        
            &#183; 
            <a href="/">
                main
            </a>
        
    
</p>
</nav>

    </main>
    
    <footer class="flex-container footer">
</footer>
    
    
</body>

</html>